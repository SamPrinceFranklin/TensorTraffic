{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/directions-service.ts"],"sourcesContent":["\n'use server';\n\nexport interface DirectionDetails {\n    distance: string;\n    duration: string;\n    durationInTraffic: string;\n    summary: string;\n    polyline: string;\n    trafficStatus: 'light' | 'moderate' | 'heavy';\n    bounds: {\n        northeast: { lat: number, lng: number };\n        southwest: { lat: number, lng: number };\n    },\n    junctions: number;\n}\n\nfunction getTrafficStatus(duration: number, durationInTraffic: number): 'light' | 'moderate' | 'heavy' {\n    const ratio = durationInTraffic / duration;\n    if (ratio < 1.2) return 'light';\n    if (ratio < 1.6) return 'moderate';\n    return 'heavy';\n}\n\nfunction countJunctions(steps: any[]): number {\n    if (!steps) return 0;\n    \n    const junctionManeuvers = [\n        'turn-sharp-left',\n        'turn-sharp-right',\n        'turn-slight-left',\n        'turn-slight-right',\n        'turn-left',\n        'turn-right',\n        'roundabout-left',\n        'roundabout-right',\n        'fork-left',\n        'fork-right',\n    ];\n\n    return steps.reduce((count, step) => {\n        if (step.maneuver && junctionManeuvers.includes(step.maneuver)) {\n            return count + 1;\n        }\n        return count;\n    }, 0);\n}\n\nexport async function getDirections(\n  origin: { lat: number; lng: number },\n  destination: { lat: number; lng: number }\n): Promise<{ success: boolean; data?: DirectionDetails[], error?: string; }> {\n  const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY;\n  if (!apiKey) {\n    return { success: false, error: \"Google Maps API key is not configured on the server.\" };\n  }\n\n  const url = new URL('https://maps.googleapis.com/maps/api/directions/json');\n  url.searchParams.append('origin', `${origin.lat},${origin.lng}`);\n  url.searchParams.append('destination', `${destination.lat},${destination.lng}`);\n  url.searchParams.append('key', apiKey);\n  url.searchParams.append('departure_time', 'now');\n  url.searchParams.append('alternatives', 'true');\n\n  try {\n    const response = await fetch(url.toString());\n    const data = await response.json();\n\n    if (data.status !== 'OK' || !data.routes || data.routes.length === 0) {\n      return { success: false, error: `Directions API error: ${data.status} - ${data.error_message || 'No routes found.'}` };\n    }\n\n    const allRoutesDetails: DirectionDetails[] = data.routes.map((route: any) => {\n        const leg = route.legs[0];\n        \n        if (!leg.distance || !leg.duration || !leg.duration_in_traffic) {\n            // This will be caught by the filter below\n            return null;\n        }\n        \n        const trafficStatus = getTrafficStatus(leg.duration.value, leg.duration_in_traffic.value);\n        const junctionCount = countJunctions(leg.steps);\n\n        return {\n          distance: leg.distance.text,\n          duration: leg.duration.text,\n          durationInTraffic: leg.duration_in_traffic.text,\n          summary: route.summary,\n          polyline: route.overview_polyline.points,\n          trafficStatus,\n          bounds: {\n            northeast: route.bounds.northeast,\n            southwest: route.bounds.southwest\n          },\n          junctions: junctionCount,\n        };\n    }).filter((details: DirectionDetails | null): details is DirectionDetails => details !== null);\n\n    if (allRoutesDetails.length === 0) {\n        return { success: false, error: 'Directions response missing required fields for all routes.' };\n    }\n\n    return { success: true, data: allRoutesDetails };\n  } catch (e) {\n    console.error(\"Error fetching directions:\", e);\n    return { success: false, error: 'An unknown error occurred while fetching directions.' };\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAiBA,SAAS,iBAAiB,QAAgB,EAAE,iBAAyB;IACjE,MAAM,QAAQ,oBAAoB;IAClC,IAAI,QAAQ,KAAK,OAAO;IACxB,IAAI,QAAQ,KAAK,OAAO;IACxB,OAAO;AACX;AAEA,SAAS,eAAe,KAAY;IAChC,IAAI,CAAC,OAAO,OAAO;IAEnB,MAAM,oBAAoB;QACtB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACH;IAED,OAAO,MAAM,MAAM,CAAC,CAAC,OAAO;QACxB,IAAI,KAAK,QAAQ,IAAI,kBAAkB,QAAQ,CAAC,KAAK,QAAQ,GAAG;YAC5D,OAAO,QAAQ;QACnB;QACA,OAAO;IACX,GAAG;AACP;AAEO,eAAe,cACpB,MAAoC,EACpC,WAAyC;IAEzC,MAAM;IACN,uCAAa;;IAEb;IAEA,MAAM,MAAM,IAAI,IAAI;IACpB,IAAI,YAAY,CAAC,MAAM,CAAC,UAAU,GAAG,OAAO,GAAG,CAAC,CAAC,EAAE,OAAO,GAAG,EAAE;IAC/D,IAAI,YAAY,CAAC,MAAM,CAAC,eAAe,GAAG,YAAY,GAAG,CAAC,CAAC,EAAE,YAAY,GAAG,EAAE;IAC9E,IAAI,YAAY,CAAC,MAAM,CAAC,OAAO;IAC/B,IAAI,YAAY,CAAC,MAAM,CAAC,kBAAkB;IAC1C,IAAI,YAAY,CAAC,MAAM,CAAC,gBAAgB;IAExC,IAAI;QACF,MAAM,WAAW,MAAM,MAAM,IAAI,QAAQ;QACzC,MAAM,OAAO,MAAM,SAAS,IAAI;QAEhC,IAAI,KAAK,MAAM,KAAK,QAAQ,CAAC,KAAK,MAAM,IAAI,KAAK,MAAM,CAAC,MAAM,KAAK,GAAG;YACpE,OAAO;gBAAE,SAAS;gBAAO,OAAO,CAAC,sBAAsB,EAAE,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,aAAa,IAAI,oBAAoB;YAAC;QACvH;QAEA,MAAM,mBAAuC,KAAK,MAAM,CAAC,GAAG,CAAC,CAAC;YAC1D,MAAM,MAAM,MAAM,IAAI,CAAC,EAAE;YAEzB,IAAI,CAAC,IAAI,QAAQ,IAAI,CAAC,IAAI,QAAQ,IAAI,CAAC,IAAI,mBAAmB,EAAE;gBAC5D,0CAA0C;gBAC1C,OAAO;YACX;YAEA,MAAM,gBAAgB,iBAAiB,IAAI,QAAQ,CAAC,KAAK,EAAE,IAAI,mBAAmB,CAAC,KAAK;YACxF,MAAM,gBAAgB,eAAe,IAAI,KAAK;YAE9C,OAAO;gBACL,UAAU,IAAI,QAAQ,CAAC,IAAI;gBAC3B,UAAU,IAAI,QAAQ,CAAC,IAAI;gBAC3B,mBAAmB,IAAI,mBAAmB,CAAC,IAAI;gBAC/C,SAAS,MAAM,OAAO;gBACtB,UAAU,MAAM,iBAAiB,CAAC,MAAM;gBACxC;gBACA,QAAQ;oBACN,WAAW,MAAM,MAAM,CAAC,SAAS;oBACjC,WAAW,MAAM,MAAM,CAAC,SAAS;gBACnC;gBACA,WAAW;YACb;QACJ,GAAG,MAAM,CAAC,CAAC,UAAkE,YAAY;QAEzF,IAAI,iBAAiB,MAAM,KAAK,GAAG;YAC/B,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA8D;QAClG;QAEA,OAAO;YAAE,SAAS;YAAM,MAAM;QAAiB;IACjD,EAAE,OAAO,GAAG;QACV,QAAQ,KAAK,CAAC,8BAA8B;QAC5C,OAAO;YAAE,SAAS;YAAO,OAAO;QAAuD;IACzF;AACF;;;IA3DsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 217, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/firebase.ts"],"sourcesContent":["// Import the functions you need from the SDKs you need\nimport { initializeApp, getApps, getApp } from \"firebase/app\";\nimport { getFirestore } from \"firebase/firestore\";\n\n// A single configuration for Firebase services for the client\nconst firebaseConfig = {\n  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\n};\n\n// A server-specific configuration, ensuring we use the correct credentials on the server\nconst firebaseServerConfig = {\n    apiKey: process.env.FIREBASE_API_KEY,\n    authDomain: process.env.FIREBASE_AUTH_DOMAIN,\n    projectId: process.env.FIREBASE_PROJECT_ID,\n    storageBucket: process.env.FIREBASE_STORAGE_BUCKET,\n    messagingSenderId: process.env.FIREBASE_MESSAGING_SENDER_ID,\n    appId: process.env.FIREBASE_APP_ID,\n};\n\n// Initialize Firebase\nconst app = !getApps().length ? initializeApp(typeof window === 'undefined' ? firebaseServerConfig : firebaseConfig) : getApp();\nconst db = getFirestore(app);\n\nexport { db };\n"],"names":[],"mappings":"AAAA,uDAAuD;;;;AACvD;AAAA;AACA;AAAA;;;AAEA,8DAA8D;AAC9D,MAAM,iBAAiB;IACrB,MAAM;IACN,UAAU;IACV,SAAS;IACT,aAAa;IACb,iBAAiB;IACjB,KAAK;AACP;AAEA,yFAAyF;AACzF,MAAM,uBAAuB;IACzB,QAAQ,QAAQ,GAAG,CAAC,gBAAgB;IACpC,YAAY,QAAQ,GAAG,CAAC,oBAAoB;IAC5C,WAAW,QAAQ,GAAG,CAAC,mBAAmB;IAC1C,eAAe,QAAQ,GAAG,CAAC,uBAAuB;IAClD,mBAAmB,QAAQ,GAAG,CAAC,4BAA4B;IAC3D,OAAO,QAAQ,GAAG,CAAC,eAAe;AACtC;AAEA,sBAAsB;AACtB,MAAM,MAAM,CAAC,CAAA,GAAA,oLAAA,CAAA,UAAO,AAAD,IAAI,MAAM,GAAG,CAAA,GAAA,oLAAA,CAAA,gBAAa,AAAD,EAAE,uCAAgC,+DAAyC,CAAA,GAAA,oLAAA,CAAA,SAAM,AAAD;AAC5H,MAAM,KAAK,CAAA,GAAA,iKAAA,CAAA,eAAY,AAAD,EAAE","debugId":null}},
    {"offset": {"line": 255, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/police-alert-service.ts"],"sourcesContent":["\n'use server';\n\nimport { db } from '@/lib/firebase';\nimport { collection, addDoc, serverTimestamp } from \"firebase/firestore\";\n\nexport interface PoliceAlertData {\n    childName: string;\n    schoolName: string;\n    overdueDuration: string;\n    timeLeftSchool: string;\n    schoolContact: string;\n    homeLocation: { lat: number; lng: number };\n    schoolLocation: { lat: number; lng: number };\n}\n\nexport async function savePoliceAlert(alertData: PoliceAlertData) {\n    try {\n        const docRef = await addDoc(collection(db, \"policeAlerts\"), {\n            ...alertData,\n            timestamp: serverTimestamp(),\n        });\n        console.log(\"Police alert document written with ID: \", docRef.id);\n        return { success: true, id: docRef.id };\n    } catch (e) {\n        console.error(\"Error adding police alert document: \", e);\n        if (e instanceof Error) {\n            if (e.message.includes('PERMISSION_DENIED')) {\n                 return { success: false, error: 'Permission Denied. Please check your Firestore security rules to allow writing to the policeAlerts collection.' };\n            }\n            return { success: false, error: e.message };\n        }\n        return { success: false, error: 'An unknown error occurred while saving the police alert.' };\n    }\n}\n"],"names":[],"mappings":";;;;;AAGA;AACA;AAAA;;;;;;AAYO,eAAe,gBAAgB,SAA0B;IAC5D,IAAI;QACA,MAAM,SAAS,MAAM,CAAA,GAAA,iKAAA,CAAA,SAAM,AAAD,EAAE,CAAA,GAAA,iKAAA,CAAA,aAAU,AAAD,EAAE,sHAAA,CAAA,KAAE,EAAE,iBAAiB;YACxD,GAAG,SAAS;YACZ,WAAW,CAAA,GAAA,iKAAA,CAAA,kBAAe,AAAD;QAC7B;QACA,QAAQ,GAAG,CAAC,2CAA2C,OAAO,EAAE;QAChE,OAAO;YAAE,SAAS;YAAM,IAAI,OAAO,EAAE;QAAC;IAC1C,EAAE,OAAO,GAAG;QACR,QAAQ,KAAK,CAAC,wCAAwC;QACtD,IAAI,aAAa,OAAO;YACpB,IAAI,EAAE,OAAO,CAAC,QAAQ,CAAC,sBAAsB;gBACxC,OAAO;oBAAE,SAAS;oBAAO,OAAO;gBAAiH;YACtJ;YACA,OAAO;gBAAE,SAAS;gBAAO,OAAO,EAAE,OAAO;YAAC;QAC9C;QACA,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2D;IAC/F;AACJ;;;IAlBsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 310, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/incidents-service.ts"],"sourcesContent":["\n'use server';\n\nimport { db } from '@/lib/firebase';\nimport { collection, addDoc, getDocs, serverTimestamp, Timestamp, doc, updateDoc, increment, getDoc, query, orderBy } from \"firebase/firestore\";\nimport { Incident, Comment } from '@/lib/types';\n\nexport interface IncidentData {\n    location: {\n        latitude: number;\n        longitude: number;\n    };\n    category: string;\n    severity: string;\n    summary: string;\n    address?: string;\n}\n\nexport async function saveIncidentReport(incidentData: IncidentData) {\n    try {\n        const docRef = await addDoc(collection(db, \"incidents\"), {\n            location: incidentData.location,\n            category: incidentData.category,\n            severity: incidentData.severity,\n            summary: incidentData.summary,\n            address: incidentData.address || null,\n            upvotes: 0,\n            timestamp: serverTimestamp(),\n        });\n        console.log(\"Document written with ID: \", docRef.id);\n        return { success: true, id: docRef.id };\n    } catch (e) {\n        console.error(\"Error adding document: \", e);\n        if (e instanceof Error) {\n            if (e.message.includes('PERMISSION_DENIED')) {\n                 return { success: false, error: 'Permission Denied. Please check your Firestore security rules in the Firebase Console. This is a common issue and is required for the app to save data.' };\n            }\n            return { success: false, error: e.message };\n        }\n        return { success: false, error: 'An unknown error occurred while saving the incident report.' };\n    }\n}\n\nexport async function getIncidents() {\n  try {\n    const querySnapshot = await getDocs(collection(db, 'incidents'));\n    const incidents: Incident[] = querySnapshot.docs.map(doc => {\n      const data = doc.data();\n      // Firestore timestamps can be null if the document is not yet fully written to the server.\n      // We provide a fallback to the current date.\n      const timestamp = (data.timestamp as Timestamp) || Timestamp.now();\n      \n      return {\n        id: doc.id,\n        location: {\n          latitude: data.location.latitude,\n          longitude: data.location.longitude,\n        },\n        category: data.category,\n        severity: data.severity,\n        summary: data.summary,\n        timestamp: timestamp.toDate().toISOString(),\n        address: data.address || undefined,\n        upvotes: data.upvotes || 0,\n      };\n    });\n    return { success: true, data: incidents };\n  } catch (e) {\n    console.error(\"Error getting documents: \", e);\n    if (e instanceof Error) {\n      if (e.message.includes('PERMISSION_DENIED')) {\n        return { success: false, error: 'Permission Denied. Could not retrieve incidents. Please check your Firestore security rules.' };\n      }\n      return { success: false, error: e.message };\n    }\n    return { success: false, error: 'An unknown error occurred while fetching incidents.' };\n  }\n}\n\nexport async function upvoteIncident(incidentId: string) {\n    try {\n        const incidentRef = doc(db, 'incidents', incidentId);\n        await updateDoc(incidentRef, {\n            upvotes: increment(1)\n        });\n        const updatedDoc = await getDoc(incidentRef);\n        if(updatedDoc.exists()){\n            return { success: true, newUpvotes: updatedDoc.data().upvotes };\n        }\n        return { success: false, error: 'Could not retrieve updated upvote count.' };\n    } catch (e: any) {\n        console.error(\"Error upvoting incident: \", e);\n        if (e.message.includes('PERMISSION_DENIED')) {\n            return { success: false, error: 'Permission Denied. Please check your Firestore security rules to allow incident updates.' };\n        }\n        return { success: false, error: e.message || 'An unknown error occurred while upvoting.' };\n    }\n}\n\nexport async function addComment(incidentId: string, commentText: string) {\n    try {\n        const commentsCollectionRef = collection(db, 'incidents', incidentId, 'comments');\n        const docRef = await addDoc(commentsCollectionRef, {\n            text: commentText,\n            author: 'Anonymous', // In a real app, this would be the logged-in user's ID/name\n            timestamp: serverTimestamp(),\n        });\n        return { success: true, id: docRef.id };\n    } catch (e: any) {\n        console.error(\"Error adding comment: \", e);\n         if (e.message.includes('PERMISSION_DENIED')) {\n            return { success: false, error: 'Permission Denied. Please check your Firestore security rules to allow writing to the comments sub-collection.' };\n        }\n        return { success: false, error: e.message || 'An unknown error occurred while adding the comment.' };\n    }\n}\n\nexport async function getComments(incidentId: string): Promise<{ success: boolean; data?: Comment[], error?: string }> {\n    try {\n        const commentsCollectionRef = collection(db, 'incidents', incidentId, 'comments');\n        const q = query(commentsCollectionRef, orderBy('timestamp', 'desc'));\n        const querySnapshot = await getDocs(q);\n        const comments: Comment[] = querySnapshot.docs.map(doc => {\n            const data = doc.data();\n            const timestamp = data.timestamp as Timestamp;\n            return {\n                id: doc.id,\n                text: data.text,\n                author: data.author,\n                timestamp: timestamp ? timestamp.toDate().toISOString() : new Date().toISOString(),\n            };\n        });\n        return { success: true, data: comments };\n    } catch (e: any) {\n        console.error(\"Error fetching comments: \", e);\n         if (e.message.includes('PERMISSION_DENIED')) {\n            return { success: false, error: 'Permission Denied. Please check your Firestore security rules to allow reading from the comments sub-collection.' };\n        }\n        return { success: false, error: e.message || 'An unknown error occurred while fetching comments.' };\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 614, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.0-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 635, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/generate-route-alert-flow.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview A flow to analyze incidents along a route and generate a summary alert.\n *\n * - generateRouteAlert - A function that handles the route alert generation process.\n * - GenerateRouteAlertInput - The input type for the generateRouteAlert function.\n * - GenerateRouteAlertOutput - The return type for the generateRouteAlert function.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\n\nconst IncidentSchema = z.object({\n  id: z.string(),\n  location: z.object({\n    latitude: z.number(),\n    longitude: z.number(),\n  }),\n  category: z.string(),\n  severity: z.string(),\n  summary: z.string(),\n  timestamp: z.string(),\n});\n\nconst GenerateRouteAlertInputSchema = z.object({\n  incidents: z.array(IncidentSchema).describe('A list of incidents detected along the user\\'s planned route.'),\n  fromAddress: z.string().describe('The starting address of the route.'),\n  toAddress: z.string().describe('The destination address of the route.'),\n  nextIncidentDistance: z.string().optional().describe('The estimated travel distance to the very next incident on the route.'),\n});\nexport type GenerateRouteAlertInput = z.infer<typeof GenerateRouteAlertInputSchema>;\n\nconst GenerateRouteAlertOutputSchema = z.object({\n  alertSummary: z.string().describe('A very short, concise, and direct summary of the key incidents on the route to be used for a voice alert. Mention the most severe issues first.'),\n  detailedAlerts: z.array(z.object({\n      incidentId: z.string(),\n      category: z.string(),\n      severity: z.string(),\n      summary: z.string(),\n  })).describe('A list of the individual alerts for the UI.'),\n});\nexport type GenerateRouteAlertOutput = z.infer<typeof GenerateRouteAlertOutputSchema>;\n\nexport async function generateRouteAlert(input: GenerateRouteAlertInput): Promise<GenerateRouteAlertOutput> {\n  return generateRouteAlertFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'generateRouteAlertPrompt',\n  input: { schema: GenerateRouteAlertInputSchema },\n  output: { schema: GenerateRouteAlertOutputSchema },\n  prompt: `You are a traffic alert system AI. Your task is to provide a very brief voice alert summary and a detailed list of incidents for a user's route from \"{{fromAddress}}\" to \"{{toAddress}}\".\n\nIncidents on route:\n{{#each incidents}}\n- **ID:** {{id}}\n- **Category:** {{category}}\n- **Severity:** {{severity}}\n- **Summary:** {{summary}}\n{{/each}}\n\n{{#if nextIncidentDistance}}\nThe next incident is about {{nextIncidentDistance}} away.\n{{/if}}\n\n**Tasks:**\n\n1.  **Generate Voice Summary:** Create a single, short sentence summarizing the most critical issues on the route. This will be read aloud. Start with \"Alert:\" and be direct. If available, mention the distance to the next incident. For example: \"Alert: There is an accident reported in about 2 miles, plus other incidents ahead.\" or \"Alert: There is heavy traffic due to an accident on Main Street and reported water logging ahead.\" If there are no major issues, say \"Alert: The route ahead is currently clear.\".\n2.  **Create Detailed List:** Create a list of all the incidents provided in the input for display in the UI.\n\nProvide the output in the structured format requested.\n`,\n});\n\nconst generateRouteAlertFlow = ai.defineFlow(\n  {\n    name: 'generateRouteAlertFlow',\n    inputSchema: GenerateRouteAlertInputSchema,\n    outputSchema: GenerateRouteAlertOutputSchema,\n  },\n  async (input) => {\n    const { output } = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,iBAAiB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC9B,IAAI,uIAAA,CAAA,IAAC,CAAC,MAAM;IACZ,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACjB,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM;QAClB,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM;IACrB;IACA,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM;IAClB,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM;IAClB,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM;IACjB,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM;AACrB;AAEA,MAAM,gCAAgC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC7C,WAAW,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,gBAAgB,QAAQ,CAAC;IAC5C,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACjC,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC/B,sBAAsB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;AACvD;AAGA,MAAM,iCAAiC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC9C,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAClC,gBAAgB,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QAC7B,YAAY,uIAAA,CAAA,IAAC,CAAC,MAAM;QACpB,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM;QAClB,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM;QAClB,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM;IACrB,IAAI,QAAQ,CAAC;AACf;AAGO,eAAe,mBAAmB,KAA8B;IACrE,OAAO,uBAAuB;AAChC;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAE,QAAQ;IAA8B;IAC/C,QAAQ;QAAE,QAAQ;IAA+B;IACjD,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;AAoBX,CAAC;AACD;AAEA,MAAM,yBAAyB,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC1C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAO;IACL,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,OAAO;IAChC,OAAO;AACT;;;IAxCoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 748, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/text-to-speech-flow.ts"],"sourcesContent":["\n'use server';\n\n/**\n * @fileOverview A flow to convert text to speech using Google's TTS model.\n *\n * - textToSpeech - A function that handles the text-to-speech conversion.\n * - TextToSpeechInput - The input type for the textToSpeech function.\n * - TextToSpeechOutput - The return type for the textToSpeech function.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\nimport wav from 'wav';\n\nconst TextToSpeechInputSchema = z.string().describe('The text to be converted to speech.');\nexport type TextToSpeechInput = z.infer<typeof TextToSpeechInputSchema>;\n\nconst TextToSpeechOutputSchema = z.object({\n    audioDataUri: z.string().describe(\"The generated audio as a data URI. Expected format: 'data:audio/wav;base64,<encoded_data>'.\"),\n});\nexport type TextToSpeechOutput = z.infer<typeof TextToSpeechOutputSchema>;\n\nexport async function textToSpeech(input: TextToSpeechInput): Promise<TextToSpeechOutput> {\n  return textToSpeechFlow(input);\n}\n\nasync function toWav(\n  pcmData: Buffer,\n  channels = 1,\n  rate = 24000,\n  sampleWidth = 2\n): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const writer = new wav.Writer({\n      channels,\n      sampleRate: rate,\n      bitDepth: sampleWidth * 8,\n    });\n\n    const bufs: any[] = [];\n    writer.on('error', reject);\n    writer.on('data', function (d) {\n      bufs.push(d);\n    });\n    writer.on('end', function () {\n      resolve(Buffer.concat(bufs).toString('base64'));\n    });\n\n    writer.write(pcmData);\n    writer.end();\n  });\n}\n\nconst textToSpeechFlow = ai.defineFlow(\n  {\n    name: 'textToSpeechFlow',\n    inputSchema: TextToSpeechInputSchema,\n    outputSchema: TextToSpeechOutputSchema,\n  },\n  async (text) => {\n    // Handle empty or whitespace-only strings to prevent TTS errors.\n    if (!text || text.trim() === '') {\n      return {\n        audioDataUri: 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA', // Empty WAV file\n      };\n    }\n\n    const { media } = await ai.generate({\n      model: 'googleai/gemini-2.5-flash-preview-tts',\n      config: {\n        responseModalities: ['AUDIO'],\n        speechConfig: {\n          voiceConfig: {\n            prebuiltVoiceConfig: { voiceName: 'Algenib' },\n          },\n        },\n      },\n      prompt: text,\n    });\n\n    if (!media) {\n      throw new Error('No media was returned from the TTS model.');\n    }\n\n    const audioBuffer = Buffer.from(\n      media.url.substring(media.url.indexOf(',') + 1),\n      'base64'\n    );\n    \n    const wavBase64 = await toWav(audioBuffer);\n\n    return {\n      audioDataUri: 'data:audio/wav;base64,' + wavBase64,\n    };\n  }\n);\n"],"names":[],"mappings":";;;;;AAGA;;;;;;CAMC,GAED;AACA;AAAA;AACA;;;;;;;AAEA,MAAM,0BAA0B,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAGpD,MAAM,2BAA2B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACtC,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACtC;AAGO,eAAe,aAAa,KAAwB;IACzD,OAAO,iBAAiB;AAC1B;AAEA,eAAe,MACb,OAAe,EACf,WAAW,CAAC,EACZ,OAAO,KAAK,EACZ,cAAc,CAAC;IAEf,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,MAAM,SAAS,IAAI,4HAAA,CAAA,UAAG,CAAC,MAAM,CAAC;YAC5B;YACA,YAAY;YACZ,UAAU,cAAc;QAC1B;QAEA,MAAM,OAAc,EAAE;QACtB,OAAO,EAAE,CAAC,SAAS;QACnB,OAAO,EAAE,CAAC,QAAQ,SAAU,CAAC;YAC3B,KAAK,IAAI,CAAC;QACZ;QACA,OAAO,EAAE,CAAC,OAAO;YACf,QAAQ,OAAO,MAAM,CAAC,MAAM,QAAQ,CAAC;QACvC;QAEA,OAAO,KAAK,CAAC;QACb,OAAO,GAAG;IACZ;AACF;AAEA,MAAM,mBAAmB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACpC;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAO;IACL,iEAAiE;IACjE,IAAI,CAAC,QAAQ,KAAK,IAAI,OAAO,IAAI;QAC/B,OAAO;YACL,cAAc;QAChB;IACF;IAEA,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,mHAAA,CAAA,KAAE,CAAC,QAAQ,CAAC;QAClC,OAAO;QACP,QAAQ;YACN,oBAAoB;gBAAC;aAAQ;YAC7B,cAAc;gBACZ,aAAa;oBACX,qBAAqB;wBAAE,WAAW;oBAAU;gBAC9C;YACF;QACF;QACA,QAAQ;IACV;IAEA,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,cAAc,OAAO,IAAI,CAC7B,MAAM,GAAG,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,OAAO,CAAC,OAAO,IAC7C;IAGF,MAAM,YAAY,MAAM,MAAM;IAE9B,OAAO;QACL,cAAc,2BAA2B;IAC3C;AACF;;;IAxEoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 842, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/places-service.ts"],"sourcesContent":["\n'use server';\n\nexport interface AutocompletePrediction {\n    placeId: string;\n    description: string;\n}\n\nexport interface PlaceDetails {\n    name: string;\n    address: string;\n    location: {\n        lat: number;\n        lng: number;\n    }\n}\n\nexport async function autocompletePlaces(\n  query: string,\n  location: { lat: number, lng: number } | null,\n): Promise<{ success: boolean; data?: AutocompletePrediction[], error?: string }> {\n  const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY;\n  if (!apiKey) {\n    return { success: false, error: \"Google Maps API key is not configured on the server.\" };\n  }\n  \n  const url = 'https://places.googleapis.com/v1/places:autocomplete';\n\n  const headers = {\n    'Content-Type': 'application/json',\n    'X-Goog-Api-Key': apiKey,\n  };\n\n  const body = JSON.stringify({\n    input: query,\n    ...(location && {\n        locationBias: {\n            circle: {\n                center: {\n                    latitude: location.lat,\n                    longitude: location.lng,\n                },\n                radius: 10000.0, // 10km radius bias\n            },\n        }\n    }),\n  });\n\n  try {\n    const response = await fetch(url, { method: 'POST', headers, body });\n    const data = await response.json();\n\n    if (data.error || !data.suggestions) {\n        return { success: false, error: `Places Autocomplete error: ${data.error?.message || 'No results'}` };\n    }\n\n    const predictions: AutocompletePrediction[] = data.suggestions.map((prediction: any) => ({\n      placeId: prediction.placePrediction.place,\n      description: prediction.placePrediction.text.text,\n    }));\n    \n    return { success: true, data: predictions };\n  } catch (e) {\n    console.error(\"Error fetching autocomplete places:\", e);\n    return { success: false, error: 'An unknown error occurred while fetching autocomplete results.' };\n  }\n}\n\nexport async function getPlaceDetails(placeId: string): Promise<{ success: boolean, data?: PlaceDetails, error?: string }> {\n     const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY;\n    if (!apiKey) {\n        return { success: false, error: \"Google Maps API key is not configured on the server.\" };\n    }\n    \n    const url = `https://places.googleapis.com/v1/${placeId}`;\n    const headers = {\n        'Content-Type': 'application/json',\n        'X-Goog-Api-Key': apiKey,\n        'X-Goog-FieldMask': 'displayName,formattedAddress,location'\n    };\n    \n    try {\n        const response = await fetch(url, { headers });\n        const data = await response.json();\n        \n        if (data.error) {\n             return { success: false, error: `Place Details error: ${data.error?.message || 'Not found'}` };\n        }\n        \n        const details: PlaceDetails = {\n            name: data.displayName.text,\n            address: data.formattedAddress,\n            location: {\n                lat: data.location.latitude,\n                lng: data.location.longitude,\n            }\n        };\n        \n        return { success: true, data: details };\n    } catch(e) {\n        console.error(\"Error fetching place details:\", e);\n        return { success: false, error: 'An unknown error occurred while fetching place details.' };\n    }\n}\n\n    "],"names":[],"mappings":";;;;;;;;;AAiBO,eAAe,mBACpB,KAAa,EACb,QAA6C;IAE7C,MAAM;IACN,uCAAa;;IAEb;IAEA,MAAM,MAAM;IAEZ,MAAM,UAAU;QACd,gBAAgB;QAChB,kBAAkB;IACpB;IAEA,MAAM,OAAO,KAAK,SAAS,CAAC;QAC1B,OAAO;QACP,GAAI,YAAY;YACZ,cAAc;gBACV,QAAQ;oBACJ,QAAQ;wBACJ,UAAU,SAAS,GAAG;wBACtB,WAAW,SAAS,GAAG;oBAC3B;oBACA,QAAQ;gBACZ;YACJ;QACJ,CAAC;IACH;IAEA,IAAI;QACF,MAAM,WAAW,MAAM,MAAM,KAAK;YAAE,QAAQ;YAAQ;YAAS;QAAK;QAClE,MAAM,OAAO,MAAM,SAAS,IAAI;QAEhC,IAAI,KAAK,KAAK,IAAI,CAAC,KAAK,WAAW,EAAE;YACjC,OAAO;gBAAE,SAAS;gBAAO,OAAO,CAAC,2BAA2B,EAAE,KAAK,KAAK,EAAE,WAAW,cAAc;YAAC;QACxG;QAEA,MAAM,cAAwC,KAAK,WAAW,CAAC,GAAG,CAAC,CAAC,aAAoB,CAAC;gBACvF,SAAS,WAAW,eAAe,CAAC,KAAK;gBACzC,aAAa,WAAW,eAAe,CAAC,IAAI,CAAC,IAAI;YACnD,CAAC;QAED,OAAO;YAAE,SAAS;YAAM,MAAM;QAAY;IAC5C,EAAE,OAAO,GAAG;QACV,QAAQ,KAAK,CAAC,uCAAuC;QACrD,OAAO;YAAE,SAAS;YAAO,OAAO;QAAiE;IACnG;AACF;AAEO,eAAe,gBAAgB,OAAe;IAChD,MAAM;IACP,uCAAa;;IAEb;IAEA,MAAM,MAAM,CAAC,iCAAiC,EAAE,SAAS;IACzD,MAAM,UAAU;QACZ,gBAAgB;QAChB,kBAAkB;QAClB,oBAAoB;IACxB;IAEA,IAAI;QACA,MAAM,WAAW,MAAM,MAAM,KAAK;YAAE;QAAQ;QAC5C,MAAM,OAAO,MAAM,SAAS,IAAI;QAEhC,IAAI,KAAK,KAAK,EAAE;YACX,OAAO;gBAAE,SAAS;gBAAO,OAAO,CAAC,qBAAqB,EAAE,KAAK,KAAK,EAAE,WAAW,aAAa;YAAC;QAClG;QAEA,MAAM,UAAwB;YAC1B,MAAM,KAAK,WAAW,CAAC,IAAI;YAC3B,SAAS,KAAK,gBAAgB;YAC9B,UAAU;gBACN,KAAK,KAAK,QAAQ,CAAC,QAAQ;gBAC3B,KAAK,KAAK,QAAQ,CAAC,SAAS;YAChC;QACJ;QAEA,OAAO;YAAE,SAAS;YAAM,MAAM;QAAQ;IAC1C,EAAE,OAAM,GAAG;QACP,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO;YAAE,SAAS;YAAO,OAAO;QAA0D;IAC9F;AACJ;;;IAtFsB;IAmDA;;AAnDA,+OAAA;AAmDA,+OAAA","debugId":null}},
    {"offset": {"line": 959, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/parental-alerts/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getDirections as '605c475562d35e360b80be5744d708475ce6db66b6'} from 'ACTIONS_MODULE0'\nexport {savePoliceAlert as '40b8addcd3357c129f3a4dc0c320a029ad806aeb66'} from 'ACTIONS_MODULE1'\nexport {getIncidents as '0036f4f9175b9166298ecf81f230471c932f9b8d35'} from 'ACTIONS_MODULE2'\nexport {generateRouteAlert as '4072c9be27302b19f5423814dd95b4bd259d9e1837'} from 'ACTIONS_MODULE3'\nexport {textToSpeech as '40e2e3b5fceeb54cd86f33dbf817153adeb8a6e950'} from 'ACTIONS_MODULE4'\nexport {autocompletePlaces as '603d691f6a2d8afc25d950676f09476be54bcf8a08'} from 'ACTIONS_MODULE5'\nexport {getPlaceDetails as '405bbe91130606ed9b9d33a6350719f17e88c55e52'} from 'ACTIONS_MODULE5'\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA","debugId":null}},
    {"offset": {"line": 1044, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/parental-alerts/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/parental-alerts/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/parental-alerts/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoS,GACjU,kEACA","debugId":null}},
    {"offset": {"line": 1058, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/parental-alerts/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/parental-alerts/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/parental-alerts/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAgR,GAC7S,8CACA","debugId":null}},
    {"offset": {"line": 1072, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}