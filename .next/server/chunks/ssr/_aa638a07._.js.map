{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/live-incidents-service.ts"],"sourcesContent":["\n'use server';\n\nimport { formatDistanceToNow } from 'date-fns';\n\nexport interface LiveIncident {\n  id: string;\n  source: 'Web' | 'Social Media' | 'Official';\n  title: string;\n  summary: string;\n  url: string;\n  timestamp: string; // ISO string\n  timeAgo: string;\n  location: string;\n}\n\ninterface PerplexitySearchResult {\n    title: string;\n    url: string;\n    // other fields are available but not strictly needed by LiveIncident\n}\n\nexport async function getLiveIncidents(location: {\n  lat: number;\n  lng: number;\n  address: string;\n}): Promise<{ success: boolean; data?: LiveIncident[], error?: string }> {\n  const apiKey = process.env.PERPLEXITY_API_KEY;\n\n  if (!apiKey) {\n    return { success: false, error: 'Perplexity API key is not configured. Please add PERPLEXITY_API_KEY to your .env file.' };\n  }\n\n  const url = \"https://api.perplexity.ai/chat/completions\";\n\n  // The prompt is now more focused and requests a response based on web search.\n  const userPrompt = `Find latest civic incidents or disruptions from the last 2 days near ${location.address}. Consolidate multiple reports of the same event into a single summary. Focus on events affecting commute like protests, tree fall, water flooding, or traffic regulation changes.`;\n  \n  const payload = {\n    model: \"sonar\",\n    messages: [\n        { \"role\": \"user\", \"content\": userPrompt }\n    ],\n  };\n\n  const headers = {\n    \"Authorization\": `Bearer ${apiKey}`,\n    \"Content-Type\": \"application/json\"\n  };\n\n  try {\n    const response = await fetch(url, {\n        method: 'POST',\n        body: JSON.stringify(payload),\n        headers: headers\n    });\n\n    const responseData = await response.json();\n\n    if (!response.ok) {\n        throw new Error(responseData.error?.message || 'Perplexity API request failed');\n    }\n    \n    // The core issue was trying to parse choice.message.content.\n    // The correct approach is to use the structured `search_results`.\n    if (!responseData.search_results || !Array.isArray(responseData.search_results)) {\n         throw new Error('Invalid response structure from Perplexity API: search_results is missing.');\n    }\n\n    const incidentsArray: PerplexitySearchResult[] = responseData.search_results;\n\n    const dataWithTimeAgo: LiveIncident[] = incidentsArray.map((item, index) => ({\n        id: `live-${index}-${new Date().getTime()}`,\n        source: 'Web', // Defaulting to web as source is not in search_results\n        title: item.title,\n        summary: 'Source: ' + new URL(item.url).hostname, // Using hostname as a brief summary\n        url: item.url,\n        timestamp: new Date().toISOString(),\n        timeAgo: 'Just now',\n        location: location.address, // The search was for this location\n    }));\n\n    return { success: true, data: dataWithTimeAgo };\n\n  } catch (error: any) {\n    console.error(\"Error fetching live incidents:\", error);\n    return { success: false, error: error.message || \"An unknown error occurred.\" };\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAsBO,eAAe,iBAAiB,QAItC;IACC,MAAM,SAAS,QAAQ,GAAG,CAAC,kBAAkB;IAE7C,IAAI,CAAC,QAAQ;QACX,OAAO;YAAE,SAAS;YAAO,OAAO;QAAyF;IAC3H;IAEA,MAAM,MAAM;IAEZ,8EAA8E;IAC9E,MAAM,aAAa,CAAC,qEAAqE,EAAE,SAAS,OAAO,CAAC,kLAAkL,CAAC;IAE/R,MAAM,UAAU;QACd,OAAO;QACP,UAAU;YACN;gBAAE,QAAQ;gBAAQ,WAAW;YAAW;SAC3C;IACH;IAEA,MAAM,UAAU;QACd,iBAAiB,CAAC,OAAO,EAAE,QAAQ;QACnC,gBAAgB;IAClB;IAEA,IAAI;QACF,MAAM,WAAW,MAAM,MAAM,KAAK;YAC9B,QAAQ;YACR,MAAM,KAAK,SAAS,CAAC;YACrB,SAAS;QACb;QAEA,MAAM,eAAe,MAAM,SAAS,IAAI;QAExC,IAAI,CAAC,SAAS,EAAE,EAAE;YACd,MAAM,IAAI,MAAM,aAAa,KAAK,EAAE,WAAW;QACnD;QAEA,6DAA6D;QAC7D,kEAAkE;QAClE,IAAI,CAAC,aAAa,cAAc,IAAI,CAAC,MAAM,OAAO,CAAC,aAAa,cAAc,GAAG;YAC5E,MAAM,IAAI,MAAM;QACrB;QAEA,MAAM,iBAA2C,aAAa,cAAc;QAE5E,MAAM,kBAAkC,eAAe,GAAG,CAAC,CAAC,MAAM,QAAU,CAAC;gBACzE,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE,IAAI,OAAO,OAAO,IAAI;gBAC3C,QAAQ;gBACR,OAAO,KAAK,KAAK;gBACjB,SAAS,aAAa,IAAI,IAAI,KAAK,GAAG,EAAE,QAAQ;gBAChD,KAAK,KAAK,GAAG;gBACb,WAAW,IAAI,OAAO,WAAW;gBACjC,SAAS;gBACT,UAAU,SAAS,OAAO;YAC9B,CAAC;QAED,OAAO;YAAE,SAAS;YAAM,MAAM;QAAgB;IAEhD,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO;YAAE,SAAS;YAAO,OAAO,MAAM,OAAO,IAAI;QAA6B;IAChF;AACF;;;IAlEsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/places-service.ts"],"sourcesContent":["\n'use server';\n\nexport interface AutocompletePrediction {\n    placeId: string;\n    description: string;\n}\n\nexport interface PlaceDetails {\n    name: string;\n    address: string;\n    location: {\n        lat: number;\n        lng: number;\n    }\n}\n\nexport async function autocompletePlaces(\n  query: string,\n  location: { lat: number, lng: number } | null,\n  types: string[]\n): Promise<{ success: boolean; data?: AutocompletePrediction[], error?: string }> {\n  const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY;\n  if (!apiKey) {\n    return { success: false, error: \"Google Maps API key is not configured on the server.\" };\n  }\n  \n  const url = 'https://places.googleapis.com/v1/places:autocomplete';\n\n  const headers = {\n    'Content-Type': 'application/json',\n    'X-Goog-Api-Key': apiKey,\n  };\n\n  const body = JSON.stringify({\n    input: query,\n    includedPrimaryTypes: types,\n    ...(location && {\n        locationRestriction: {\n            circle: {\n                center: {\n                    latitude: location.lat,\n                    longitude: location.lng,\n                },\n                radius: 10000.0, // 10km radius bias\n            },\n        }\n    }),\n  });\n\n  try {\n    const response = await fetch(url, { method: 'POST', headers, body });\n    const data = await response.json();\n\n    if (data.error || !data.suggestions) {\n        return { success: false, error: `Places Autocomplete error: ${data.error?.message || 'No results'}` };\n    }\n\n    const predictions: AutocompletePrediction[] = data.suggestions.map((prediction: any) => ({\n      placeId: prediction.placePrediction.place,\n      description: prediction.placePrediction.text.text,\n    }));\n    \n    return { success: true, data: predictions };\n  } catch (e) {\n    console.error(\"Error fetching autocomplete places:\", e);\n    return { success: false, error: 'An unknown error occurred while fetching autocomplete results.' };\n  }\n}\n\nexport async function getPlaceDetails(placeId: string): Promise<{ success: boolean, data?: PlaceDetails, error?: string }> {\n     const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY;\n    if (!apiKey) {\n        return { success: false, error: \"Google Maps API key is not configured on the server.\" };\n    }\n    \n    const url = `https://places.googleapis.com/v1/${placeId}`;\n    const headers = {\n        'Content-Type': 'application/json',\n        'X-Goog-Api-Key': apiKey,\n        'X-Goog-FieldMask': 'displayName,formattedAddress,location'\n    };\n    \n    try {\n        const response = await fetch(url, { headers });\n        const data = await response.json();\n        \n        if (data.error) {\n             return { success: false, error: `Place Details error: ${data.error?.message || 'Not found'}` };\n        }\n        \n        const details: PlaceDetails = {\n            name: data.displayName.text,\n            address: data.formattedAddress,\n            location: {\n                lat: data.location.latitude,\n                lng: data.location.longitude,\n            }\n        };\n        \n        return { success: true, data: details };\n    } catch(e) {\n        console.error(\"Error fetching place details:\", e);\n        return { success: false, error: 'An unknown error occurred while fetching place details.' };\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AAiBO,eAAe,mBACpB,KAAa,EACb,QAA6C,EAC7C,KAAe;IAEf,MAAM;IACN,uCAAa;;IAEb;IAEA,MAAM,MAAM;IAEZ,MAAM,UAAU;QACd,gBAAgB;QAChB,kBAAkB;IACpB;IAEA,MAAM,OAAO,KAAK,SAAS,CAAC;QAC1B,OAAO;QACP,sBAAsB;QACtB,GAAI,YAAY;YACZ,qBAAqB;gBACjB,QAAQ;oBACJ,QAAQ;wBACJ,UAAU,SAAS,GAAG;wBACtB,WAAW,SAAS,GAAG;oBAC3B;oBACA,QAAQ;gBACZ;YACJ;QACJ,CAAC;IACH;IAEA,IAAI;QACF,MAAM,WAAW,MAAM,MAAM,KAAK;YAAE,QAAQ;YAAQ;YAAS;QAAK;QAClE,MAAM,OAAO,MAAM,SAAS,IAAI;QAEhC,IAAI,KAAK,KAAK,IAAI,CAAC,KAAK,WAAW,EAAE;YACjC,OAAO;gBAAE,SAAS;gBAAO,OAAO,CAAC,2BAA2B,EAAE,KAAK,KAAK,EAAE,WAAW,cAAc;YAAC;QACxG;QAEA,MAAM,cAAwC,KAAK,WAAW,CAAC,GAAG,CAAC,CAAC,aAAoB,CAAC;gBACvF,SAAS,WAAW,eAAe,CAAC,KAAK;gBACzC,aAAa,WAAW,eAAe,CAAC,IAAI,CAAC,IAAI;YACnD,CAAC;QAED,OAAO;YAAE,SAAS;YAAM,MAAM;QAAY;IAC5C,EAAE,OAAO,GAAG;QACV,QAAQ,KAAK,CAAC,uCAAuC;QACrD,OAAO;YAAE,SAAS;YAAO,OAAO;QAAiE;IACnG;AACF;AAEO,eAAe,gBAAgB,OAAe;IAChD,MAAM;IACP,uCAAa;;IAEb;IAEA,MAAM,MAAM,CAAC,iCAAiC,EAAE,SAAS;IACzD,MAAM,UAAU;QACZ,gBAAgB;QAChB,kBAAkB;QAClB,oBAAoB;IACxB;IAEA,IAAI;QACA,MAAM,WAAW,MAAM,MAAM,KAAK;YAAE;QAAQ;QAC5C,MAAM,OAAO,MAAM,SAAS,IAAI;QAEhC,IAAI,KAAK,KAAK,EAAE;YACX,OAAO;gBAAE,SAAS;gBAAO,OAAO,CAAC,qBAAqB,EAAE,KAAK,KAAK,EAAE,WAAW,aAAa;YAAC;QAClG;QAEA,MAAM,UAAwB;YAC1B,MAAM,KAAK,WAAW,CAAC,IAAI;YAC3B,SAAS,KAAK,gBAAgB;YAC9B,UAAU;gBACN,KAAK,KAAK,QAAQ,CAAC,QAAQ;gBAC3B,KAAK,KAAK,QAAQ,CAAC,SAAS;YAChC;QACJ;QAEA,OAAO;YAAE,SAAS;YAAM,MAAM;QAAQ;IAC1C,EAAE,OAAM,GAAG;QACP,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO;YAAE,SAAS;YAAO,OAAO;QAA0D;IAC9F;AACJ;;;IAxFsB;IAqDA;;AArDA,+OAAA;AAqDA,+OAAA","debugId":null}},
    {"offset": {"line": 206, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/live-agent/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getLiveIncidents as '40345ca53538fa85c76ef155f22942baa3aeea00ea'} from 'ACTIONS_MODULE0'\nexport {autocompletePlaces as '703d691f6a2d8afc25d950676f09476be54bcf8a08'} from 'ACTIONS_MODULE1'\nexport {getPlaceDetails as '405bbe91130606ed9b9d33a6350719f17e88c55e52'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AACA","debugId":null}},
    {"offset": {"line": 267, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/live-agent/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/live-agent/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/live-agent/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAA+R,GAC5T,6DACA","debugId":null}},
    {"offset": {"line": 281, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/live-agent/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/live-agent/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/live-agent/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAA2Q,GACxS,yCACA","debugId":null}},
    {"offset": {"line": 295, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}